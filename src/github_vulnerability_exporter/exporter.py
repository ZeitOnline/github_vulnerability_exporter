import argparse
import logging
import prometheus_client
import prometheus_client.core
import prometheus_client.exposition
import requests
import sys
import time


log = logging.getLogger(__name__)
LOG_FORMAT = '%(asctime)s %(levelname)-5.5s [%(name)s] %(message)s'


class Gauge(prometheus_client.core.GaugeMetricFamily):

    def clone(self):
        return type(self)(
            self.name, self.documentation, labels=self._labelnames)


class VulnerabilityCollector:

    def configure(self, organization, authtoken):
        self.organization = organization
        self.authtoken = authtoken

    METRICS = {
        'vulnerabilities': Gauge(
            'github_vulnerability_alerts',
            'Security vulnerabilities reported by GitHub, by repository',
            labels=['repository']),
        'scrape_duration': Gauge(
            'ghvuln_scrape_duration_seconds',
            'Duration of GitHub API scrape'),
    }

    def describe(self):
        return self.METRICS.values()

    def collect(self):
        start = time.time()
        # Use a separate instance for each scrape request, to prevent
        # race conditions with simultaneous scrapes.
        metrics = {
            key: value.clone() for key, value in self.METRICS.items()}

        has_next = True
        cursor = ''
        while has_next:
            r = self.graphql(self.QUERY % {
                'organization': self.organization,
                'cursor': cursor})
            data = r['data']['organization']['repositories']
            page = data['pageInfo']
            has_next = page['hasNextPage']
            cursor = page['endCursor']

            for repo in data['nodes']:
                alerts = repo['vulnerabilityAlerts']['nodes']
                metrics['vulnerabilities'].add_metric(
                    ('%s/%s' % (self.organization, repo['name']),),
                    len(alerts))
                # Does not fit the prometheus data model.
                # packages = [
                #     x['securityVulnerability']['package']['name']
                #     for x in alerts]
        metrics['scrape_duration'].add_metric((), time.time() - start)
        return metrics.values()

    QUERY = """query {
    organization(login:"%(organization)s") {
      repositories(first:10, after:"%(cursor)s") {
        nodes {
          name vulnerabilityAlerts(first:10) {
            nodes {
              securityVulnerability {
                package {
                  name
                }
              }
            }
          }
        }

        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }}
    """

    def graphql(self, query):
        r = requests.post(
            'https://api.github.com/graphql', json={'query': query},
            headers={
                'Authorization': 'Bearer %s' % self.authtoken,
                # vulnerabilities are currently in beta, see
                # <https://developer.github.com/v4/previews/>
                'Accept': 'application/vnd.github.vixen-preview+json',
            })
        r.raise_for_status()
        return r.json()


COLLECTOR = VulnerabilityCollector()
# We don't want the `process_` and `python_` metrics, we're a collector,
# not an exporter.
REGISTRY = prometheus_client.core.CollectorRegistry()
REGISTRY.register(COLLECTOR)
APP = prometheus_client.make_wsgi_app(REGISTRY)


def main():
    parser = argparse.ArgumentParser(
        description='Export GitHub vulnerability alerts as prometheus metrics')
    parser.add_argument('--organization', help='GitHub organization name')
    parser.add_argument('--authtoken', help='GitHub API token')
    parser.add_argument('--port', default=9597, type=int, help='Listen port')
    options = parser.parse_args()
    if not all([options.organization, options.authtoken]):
        parser.print_help()
        raise SystemExit(1)
    logging.basicConfig(
        stream=sys.stdout, level=logging.INFO, format=LOG_FORMAT)

    COLLECTOR.configure(options.organization, options.authtoken)

    log.info('Listening on 0.0.0.0:%s', options.port)
    httpd = prometheus_client.exposition.make_server(
        '', options.port, APP,
        handler_class=prometheus_client.exposition._SilentHandler)
    httpd.serve_forever()
